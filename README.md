笔记来自b站“遇见狂神说”  

# 普通方法调用和多线程

<img src="E:\java\多线程\image-20220326204539739.png" alt="image-20220326204539739" style="zoom:80%;" />

# 多线程三种创建方式

线程开启不一定立即执行，由CPU调度安排。

## 继承Thread类

* 自定义线程类继承Thread类
* 重写run()方法，编写线程执行体
* 创建线程对象，调用start()方法启动线程

## 实现Runnable接口

* 定义MyRunnable类实现Runnable接口
* 实现run()方法，编写线程执行体
* **创建线程对象**，调用start()方法启动线程

方便同一个对象被多个线程使用

## 实现Callable接口

* 实现Callable接口，需要返回值类型
* 重写call方法，需要抛出异常
* 创建目标对象
* 创建执行任务：ExecutorService ser = Executors.newFixedThreadPool(1);
* 提交执行：Future<Boolean\> result1 = ser.submit(t1);
* 获取结果：boolean r1 = result1.get();
* 关闭服务：ser.shutdownNow(); 

# 静态代理

# **Lambda**表达式

避免匿名内部类定义过多

其实质属于函数式编程的概念

## 函数式接口的定义

* 任何接口，如果只包含唯一**一个**抽象方法，那么它就是一个函数式接口。

```java
public interface Runnable{
    public abstract void run();
}
```

* 对于函数式接口，我们可以通过lambda表达式来创建该接口的对象。

## 简化

1. 去掉参数类型，多个参数也可以简化，要去掉都去掉
2. 去掉括号()，多个参数不能简化
3. 去掉花括号{}，有多行代码不能简化

# 线程状态

* `Thread t = new Thread() `线程对象一旦创建就进入了**新生状态**。
* 当调用start()方法，线程立即进入**就绪状态**，但不意味着立即调度。
* 当调用sleep，wait或同步锁定时，线程进入**阻塞状态**，就是代码不往下执行，阻塞事件解除后，重新进入就绪状态，等待cpu调度执行。
* 进入**运行状态**，线程才真正执行线程体的代码。
* 线程中断或结束，一旦进入**死亡状态**，就**不能再次启动**。

 # 线程方法

| 方法                            | 说明                                       |
| :------------------------------ | ------------------------------------------ |
| `setPriority(int newPriority)`  | 更改线程优先级                             |
| `static void sleep(long mills)` | 在指定的毫秒数内让当前正在执行的线程体休眠 |
| `void join()`                   | 等待该线程终止                             |
| `static void yield()`           | 暂停当前正在执行的线程对象，并执行其他线程 |
| `void interrupt()`              | 中断线程，别用这个方式                     |
| `boolean isAlive()`             | 测试线程是否处于活动状态                   |

# 线程休眠

* sleep（事件）指定当前线程阻塞的毫秒数；
* sleep存在异常InterruptedException；
* sleep时间达到后线程进入就绪状态；
* sleep可以模拟网络延时，倒计时等。
* 每一个对象都有一个锁，sleep不会释放锁。

# 线程礼让

yield

* 礼让线程，让当前正在执行的线程暂停，但不阻塞
* 将线程从运行状态转为就绪状态
* 让cpu重新调度，礼让不一定成功！看cpu心情

# 线程强制执行

* Join合并线程，待此线程执行完成后，再执行其他线程，其他线程阻塞
* 可以想象成插队

 # 线程状态观测

* NEW 尚未启动的线程处于此状态。
* RUNNABLE 在Java虚拟机中执行的线程处于此状态。
* BLOCKED 被阻塞等待监视器锁定的线程处于此状态。
* WAITING 正在等待另一个线程执行特定动作的线程处于此状态。
* TIME_WAITING 正在等待另一个线程执行动作达到指定等待时间的线程处于此状态。
* TERMINATED 已退出的线程处于此状态。

一个线程可以在给定时间点处于一个状态。这些状态是不反应任何操作系统线程状态的虚拟机状态。

# 线程优先级

* Java提供一个线程调度器来监控程序中启动后进入就绪状态的所有线程，线程调度器按照优先级决定应该调度哪个线程来执行。
* 线程的优先级用数字表示，范围从1~10.
  * `Thread.MIN_PRIORITY = 1;`
  * `Thread.MAX_PRIORITY = 10;`
  * `Thread.NORM_PRIORITY = 5;`
* 使用以下方式改变或获取优先级
  * `getPriority().setPriority(int xxx);`

# 守护(daemon)线程

* 线程分为**用户线程**和**守护线程**
* 虚拟机确保用户线程执行完毕
* 虚拟机不用等待守护线程执行完毕
* 如，后台记录操作日志、监控内存、垃圾回收等..

# 线程同步

* 由于同一个线程的多个线程共享同一块存储空间，在带来方便的同时，也带来了访问冲突问题，为了保证数据在方法中被访问时的正确性，在访问时加入**锁机制synchronized**，当一个线程获得对象的排他锁，独占资源，其他线程必须等待，使用后释放锁即可，存在以下问题：
  * 一个线程持有锁会导致其他所有需要此锁的线程挂起；
  * 在多线程竞争下，加锁，释放锁会导致比较多的上下文切换和调度延时，引起性能问题；
  * 如果一个优先级高的线程等待一个优先级低的线程释放锁会导致优先级倒置，引起性能问题。

* 由于我们可以通过private关键字来保证数据对象只能被方法访问，所以我们只需要针对方法提出一套机制，这套机制就是synchronized关键字，它包括两种方法：synchronized方法和synchronized块。

  * 同步方法：`public synchronized void method(int args){}`
    * synchronized方法控制对”对象''的访问，每个对象对应一把锁，每个synchronized方法都必须获得调用该方法的对象的锁才能执行，否则线程会阻塞，方法一旦执行，就独占该锁，直到该方法返回才释放锁，后面被阻塞的线程才能获得这个锁，继续执行

  ​       缺陷：**若将一个大方法申明为synchronized将会影响效率**

  * 同步块：`synchronized(Obj){}`
    * Obj称之为同步监视器，Obj可以是任何对象，但是推荐使用**共享资源**作为同步监视器

# 死锁

# Lock（锁）

* ReentrantLock类实现了Lock，显示加锁、解锁，感觉类似操作系统里面的PV操作。

# 线程池

* 背景：经常创建和销毁、使用量特别大的资源，比如并发情况下的线程，对性能影响很大。
* 思路：提前创建好多个线程，放入线程池中，使用时直接获取，使用完放回池中。可以避免频繁创建销毁、实现重复利用。类似生活中的交通工具。
* 好处：
  * 提高响应速度（减少了创建新线程的时间）
  * 降低消耗资源（重复利用线程池中线程，不需要每次都创建）
  * 便于线程管理
    * corePoolSize：核心池的大小
    * maximunPoolSize：最大线程数
    * keepAliveTime：线程没有任务时最多保持多长时间后会终止
* 使用线程池
  * JDK5.0起提供了线程池相关API：ExecutorService和Executors
  * ExecutorService：真正的线程池接口。常见子类ThreadPoolExecutor
    * void execute(Runnable command)：执行任务/命令，没有返回值，一般用来执行Runnable
    * <T\>Future<T\>submit(Callable<T\> task)：执行任务，有返回值，一般又来执行Callable
    * void shutdown()：关闭连接池
  * Executors：工具类、线程池的工厂类，用于创建并返回不同类型的线程池
